---  
layout: hunter_post  
title: servers  
permalink: /class5/  
categories: [servers, webhooks, JSON]
tags: [network infrastructure, backend]
description: This week we'll learn about servers. What are they? How do you make one? Is everything really just a file?
assignment: Write a server that serves some information about your computer. Define an endpoint where we can find this information, which we'll talk to next class.
readings: Karly Wildenhaus [*Towards a Library Without Walls*](https://www.are.na/blog/towards-a-library-without-walls)<br>Daniel Romein (Bellingcat) [*Europol's Asian City Child Abuse Photographs Geolocated*](https://www.bellingcat.com/resources/case-studies/2018/11/08/europols-asian-city-child-abuse-photographs-geolocated/)
assignment-due: 03/08
---  

{{ page.description }}

### intro: media archaeology

What did everyone do? Find anything weird or interesting?

reading questions:  
* do you think companies should be held responsible for what gets hosted on their servers?
* after reading these articles, what mental image of a server are you left with?

### lecture: the 'back end'  

What is a server?

[**servers are just other computers**](https://commons.wikimedia.org/wiki/File:First-server-cern-computer-center.jpg) -- this is not only kind of neat, but it implies, by proxy, that your computer can be a server. It can! We'll make it into one later in this class. 

When we talk about servers in the context of this class, we're talking about web servers, aka HTTP servers. These are computers configured to handle requests for webpages, and the other stuff that's linked to webpages, like images and Javascript. They might also be able to generate *new* HTML pages dynamically using scripting languages like PHP, but we'll get to that in a second. 

[**everything is a file**](https://en.wikipedia.org/wiki/Everything_is_a_file)  

One of the web precursors that never really took off was a project at Bell Labs called [plan 9](https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs). The central idea was that every computer in the building was part of a distributed operating system, where computation-intensive processes were handled on a central CPU, and everyone was part of the same distributed filesystem.

One of the more interesting server artworks is a piece by net artists Eva and Franco Mattes called [life sharing](http://0100101110101101.org/life-sharing/), where they gave anyone who wanted it access to their computer, from 2000-2003.  


[**ports**](https://en.wikipedia.org/wiki/Port_(computer_networking))  

All servers operate through ports. We mentioned these last week, but they're worth revisiting. Whenever you make a request to another computer, that request gets made through what's called a *port*. Different ports are used for different kinds of requests.

If you want the computer to *serve* some specific information, you can host it on a port. It doesn't matter which one you use, so long as the port number is >1000 (as ports with smaller numbers than that are reserved.) So, if I wanted to serve 3 websites from my computer, I could serve one on port 3000, one on port 4000, and one on port 5000.... and if you went to my computer's IP address and looked at the 3 different ports, you'd see a different thing every time.

**firewalls ðŸ”¥**  

Firewalls are a safety measure used to prevent malicious web traffic from coming into a computer's ports. 'firewalls' were originally walls used to confine fires between buildings, and in general they're used to prevent the spread of things like viruses and malware.

The simplest kind of firewall is a packet filter, which blocks information from coming into a computer through ports unless it follows particular rules.

These have been around since the late 1980s, and are part of a long, exciting history of adversarial computing. One common firewall technique on large systems (like school computing systems) is something called 'Network Address Translation' or NAT. We'll come up against this later when we try and connect to each other's computers, but essentially it modifies how IP addresses are formatted in a network, hiding lots of IP addresses behind a larger one. 


[**nodeJS**](https://nodejs.org/en/)  

It used to be that Javascript only worked 'client-side': that is, you could only use it while linked in webpages. In 2009, NodeJS was released, which allowed people to execute Javascript code *outside* of a browser. Most excitingly, it allows you to write a server just using Javascript.

We're going to use NodeJS today to make our servers.

**the node package manager**

One of the cool things about node is that, because of its support for modules, all sorts of people have written all kinds of cool plugins for it. What's nice is that it means you can use a lot of other people's code without having to write your own (neat) though it does mean that a lot of web projects now get kind of bulky, cause they use so much of other people's Javascript. These modules, called 'packages' are added to projects using some software calledÂ npm. It's worth [installing it right](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally) when you first start using it -- it takes a little longer but it'll save a lot of hassle later on.  

Becuase of the number of different packages people use, there's now a manager *for* the node package manager (lol) called [yarn](https://yarnpkg.com/). For ages I thought this was kind of silly, but it does make your life a lot easier for managing large projects.

**middleware**

Middleware in this context is the stuff that sits between a client and the server, and makes it easy to pass things between them. It's also known as 'software glue', and is generally pretty useful for interoperability between different types of code. The middleware used most commonly for NodeJS apps is called [expressJS](https://expressjs.com/), and it's pretty neat and easy to use! We'll take a look at it in a minute, but check out [this tutorial](https://codeforgeek.com/express-nodejs-tutorial/) to get started.

**server-side scripting**  

Say you're Mark Zuckerberg in 2006, and you're in charge of a website where people can make personal accounts. Naively, the simplest way to handle someone getting a new account would be for them to email you with what they want on their page, and you make a new HTML page for them. This, for obvious reasons, doesn't really scale (and is pretty cumbersome even for a few people). The way you solve this problem (and Facebook continues to to this day!) is by using a 'server-side scripting language' like [PHP](https://www.w3schools.com/php/php_intro.asp), which can dynamically generate new webpages from a template.

PHP stands for 'PHP: Hypertext Processor' (episode 100000 of computer people love dumb acronyms). Now, when someone makes an account on your website, a page gets generated for them. Using PHP, this page can be changed and updated by the user, without them having to edit a single line of code. Instead, they just fill in 'forms', which add information to a database.

If you don't want to use PHP, there are actually a bunch of different ways to solve this problem. NodeJS didn't exist when Facebook first got made, but has pretty elegant support for server-side scripting, and importantly lets you use Javascript all the way down.

**hosting servers/CDNs**  

These days, if you want to set up a web server, chances are you're doing it using a hosting service. The main ones are Heroku and Amazon Web Services, both of which use an 'elastic' model: you pay for how much bandwith you use up, and that can expand and contract.

Paul Ford, in the reading about tilde.club, was using AWS to host a 'Virtual Machine', which contains all the tilde.club accounts. The architecture is super simple: it's just a bunch of HTML files on a computer in the cloud: whenever someone makes a request to the tilde.club server, it sends back the page you went to.

However, the things you 'need' a dedicated server for these days are getting fewer. In part, this is due to the proliferation of 'serverless' hosting services.

**going serverless** 

Services like Netlify and Github Pages call themselves 'serverless' -- giving users the ability to host static webpages without . Netlify actually has support for more dynamic use, including running Node servers, and React apps, both of which can do things like dynamic page generation, which before you'd have needed something like PHP to do. The main limitations of these services is that they don't store data: so, if you're running a website with lots of users updating content, you still probably want to use a database.

However, for sites with a smallish amount of data, you can still make things work. As an example of what you can do without a server I'll go through the architecture of my studio's website.

What's important to remember with these 'serverless' solutions is that they still do, definitely, involve servers. You just don't configure them. This is normally a bit of a blessing (servers are hard), but it does mean you have a lot less control over the service itself.

### in class assignment
Making a server!

To serve a webpage that just says 'hello world', you would use the following code in a file called 'index.js':

```
var http = require('http');
 
function requestHandler(req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.send('<h1>hello world!</h1>');
}
 
http.createServer(requestHandler).listen(8080, function(){
    console.log("server listening on port 8080");
});
```
To run this server, navigate to the same directory using the command line, and type 

```
node index.js
```

After you do this, the following message should appear in your terminal:

```
server listening on port 8080
```

This:
* creates a http server
* sets it up to listen for anything trying to connect to port 8080 on your computer
* creates a 'requestHandler': every time the server recieves a request ('req') -- that's anything that goes to port 8080 of your computer, it needs to come out with a response. 

To check this works, we can go to localhost:8080 and check it out! Try editing the HTML to create a different page! 

**more complex: handling http endpoints**

In order to show different pages depending on the url in our address bar, we want to use something called 'routing'. For this, we'll want the 'express' middleware I mentioned earlier. To use express, you'll want to download it first using the 'node package manager'. 

First we need to set up our node environment. To do this, type:

```
npm init
```
into the command line, and press enter through each question. This will set up the project Now, type:

```
npm install express
```
and you should see a neat little loading bar, and the package has installed.

If you type `ls` into your command line, you should now see two new things: a folder called `node_modules`, and a file called `package.json`. These are used for managing the project, and we don't need to worry about them right now.

Now we can update our server file with a new HTTP endpoint:

```
var express = require('express');
var app = express();
var path = require('path');

app.get('/', function(req, res) {
    res.send('<h1>hello world!</h1>');
});

app.get('/about', function(req, res) {
    res.send('<h1>About Page</h1><p>boo boo be doo</p>');
});

app.listen(8080);
```

Now, every time I go to the main webpage, I see the same thing as before. But if I go to localhost:8080/about, I get a different page! cool! That's becuase the express middleware can act as a router, directing us to different webpages on the same site. We can add as many of these as we like!

**looking at each other's pages**
For this part, we all need to do two things

1. connect to a local wifi network
2. find our IP addresses once we're connected to that network

Why local Wifi?  


**How to find my IP address?**  
If you're using a mac, copy and paste this line into your terminal:

```
ipconfig getifaddr en0
```

If you're using windows, try this:  
1. 'select the Start button , start typing View network connections, and then select it in the list'
2. Select the piratebox network connection, and then, in the toolbar, select View status of this connection. (You might need to select the chevron icon to find this command.)
3. Select Details.
4. Your PC's IP address appears in the Value column, next to IPv4 Address.

obvious limitations and their solutions:
* this only works on local wifi! this can be solved temporarily using a service like ngrok, which configures an outward 
* when i shut my laptop, the server turns off! to have a dedicated web server, you want a machine that's on and connected all the time. This is part of the reason why cloud services and CDNs are so popular, cause you don't need to worry about someone at Google accidentally unplugging the machine hosting your site. To do this at home, though, is also pretty fine: get an old computer and install Linux on it, then plug it in in the corner of a room with a big 'do not touch' sign on it.
* If you're making a performance web server, chances are you're not writing it yourself, as there's a lot of really complex things it has to do to perform consistently under different conditions. Popular web servers are things like [Nginx](https://en.wikipedia.org/wiki/Nginx) (pronounced 'engine X', not 'n-ginks'), and [Apache](https://en.wikipedia.org/wiki/Apache_HTTP_Server). These boast all kinds of fancy features that you'd struggle to write by hand, but are possibly overkill for smaller projects like the ones we'll do in class.

### assignment:
*due {{page.assignment-due}}*<br>
{{page.assignment}}

'Information' here is pretty broad, but it should be something that changes over time. Maybe it's something happening on the keyboard, a button you're clicking, or how many tabs you have open in google right now...
