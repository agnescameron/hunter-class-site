---  
layout: hunter_post  
title: servers  
permalink: /class5/  
categories: [servers, webhooks, JSON]
tags: [network infrastructure, backend]
description: This week we'll learn about servers. What are they? How do you make one? Is everything really just a file?
assignment: Write a server that serves some information about your computer. Define an endpoint where we can find this information, which we'll talk to next class.
readings: Karly Wildenhaus [*Towards a Library Without Walls*](https://www.are.na/blog/towards-a-library-without-walls)<br>Daniel Romein (Bellingcat) [*Europol's Asian City Child Abuse Photographs Geolocated*](https://www.bellingcat.com/resources/case-studies/2018/11/08/europols-asian-city-child-abuse-photographs-geolocated/)
assignment-due: 03/08
---  

{{ page.description }}

### intro: media archaeology

What did everyone do? Find anything weird or interesting?

reading questions:  
* do you think companies should be held responsible for what gets hosted on their servers?
* after reading these articles, what mental image of a server are you left with?

### lecture: the 'back end'  

What is a server?

[**servers are just other computers**](https://commons.wikimedia.org/wiki/File:First-server-cern-computer-center.jpg) -- this is not only kind of neat, but it implies, by proxy, that your computer can be a server. It can! We'll make it into one later in this class. 

When we talk about servers in the context of this class, we're talking about web servers, aka HTTP servers. These are computers configured to handle requests for webpages, and the other stuff that's linked to webpages, like images and Javascript. They might also be able to generate *new* HTML pages dynamically using scripting languages like PHP, but we'll get to that in a second. 

What makes a computer a server?

The role that servers play is to store st

[**everything is a file**](https://en.wikipedia.org/wiki/Everything_is_a_file)  
One of the web precursors that never really took off was a project at Bell Labs called [plan 9](https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs). The central idea was that every computer in the building was part of a distributed operating 

Â Â [unix filesystem](https://en.wikipedia.org/wiki/Unix_filesystem#Conventional_directory_layout)  
Â 
Â Â [9-front]()

One of the more interesting server artworks is a piece by net artists Eva and Franco Mattes called [life sharing](http://0100101110101101.org/life-sharing/), where they gave anyone who wanted it access to their computer, from 2000-2003.  


[**ports**](https://en.wikipedia.org/wiki/Port_(computer_networking))  
Â Â *cool ports you should know*  
Remember last week, where we were looking at 

**firewalls ðŸ”¥**  
Firewalls are a safety measure used 

Packet filter

These have been around since the late 1980s, and are part of a long, exciting history of adversarial computing. 

**server-side scripting**  
Say you're Mark Zuckerberg in 2006, and you're in charge of a website where people can make personal accounts. Naively, the simplest way to handle someone getting a new account would be for them to email you with what they want on their page, and you make a new HTML page for them. This, for obvious reasons, doesn't really scale (and is pretty cumbersome even for a few people). The way you solve this problem (and Facebook continues to to this day!) is by using a 'server-side scripting language' like [PHP](https://www.w3schools.com/php/php_intro.asp), which can dynamically generate new webpages from a template.

PHP stands for 'PHP: Hypertext Processor' (episode 100000 of computer people love dumb acronyms). Now, when someone makes an account on your website, a page gets generated for them. Using PHP, this page can be changed and updated by the user, without them having to edit a single line of code. Instead, they just fill in 'forms', which add information to a database.

If you don't want to use PHP, there are actually a bunch of different ways to solve this problem. NodeJS didn't exist when Facebook first got made, but has pretty elegant support for server-side scripting, and importantly lets you use Javascript all the way down.

[**nodeJS**](https://nodejs.org/en/)  

It used to be that Javascript only worked 'client-side': that is, you could only use it while linked in webpages. In 2009, NodeJS was released, which allowed people to execute Javascript code *outside* of a browser. Most excitingly, it allows you to write a server just using Javascript.

We're going to use NodeJS today to make our servers.

**the node package manager**

One of the cool things about node is that, because of its support for modules, all sorts of people have written all kinds of cool plugins for it. What's nice is that it means you can use a lot of other people's code without having to write your own (neat) though it does mean that a lot of web projects now get kind of bulky, cause they use so much of other people's Javascript. These modules, called 'packages' are added to projects using some software calledÂ npm. It's worth [installing it right](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally) when you first start using it -- it takes a little longer but it'll save a lot of hassle later on.  

Becuase of the number of different packages people use, there's now a manager *for* the node package manager (lol) called [yarn](https://yarnpkg.com/). For ages I thought this was kind of silly, but it does make your life a lot easier for managing large projects.


**middleware**

Middleware in this context is the stuff that sits between a client and the server, and makes it easy to pass things between them. It's also known as 'software glue', and is generally pretty useful for interoperability between different types of code. 



**hosting servers/CDNs**  

These days, if you want to set up a web server, chances are you're doing it using a hosting service. The main ones are Heroku and Amazon Web Services, both of which use an 'elastic' model: you pay for how much bandwith you use up, and that can expand and contract.

Paul Ford, in the reading about tilde.club, was using AWS to host a 'Virtual Machine', which contains all the tilde.club accounts. The architecture is super simple: it's just a bunch of HTML files on a computer in the cloud: whenever someone makes a request to the tilde.club server, it sends back the page you went to.

However, the things you 'need' a dedicated server for these days are getting fewer. In part, this is due to the proliferation of 'serverless' hosting services.

**going serverless** 

Services like Netlify and Github Pages call themselves 'serverless' -- giving users the ability to host static webpages without . Netlify actually has support for more dynamic use, including running Node servers, and React apps, both of which can do things like dynamic page generation, which before you'd have needed something like PHP to do. The main limitations of these services is that they don't store data: so, if you're running a website with lots of users updating content, you still probably want to use a database.

However, for sites with a smallish amount of data, you can still make things work. As an example of what you can do without a server I'll go through the architecture of my studio's website.

What's important to remember with these 'serverless' solutions is that they still do, definitely, involve servers. You just don't configure them. This is normally a bit of a blessing (servers are hard), but it does mean you have a lot less control over the service itself.

**local comms**  
Â Â [serial]()  
Â Â [USB]  
Â Â [USB device classes](https://en.wikipedia.org/wiki/USB#Device_classes) [Arduino mouse](https://www.arduino.cc/reference/en/language/functions/usb/mouse/) [keyboard](https://www.arduino.cc/reference/en/language/functions/usb/keyboard/) [makey makey](https://makeymakey.com)  

[**lan parties**](https://en.wikipedia.org/wiki/LAN_party)  
In this class, we're going to use Piratebox.


**making places**  
Â Â [tilde.club](https://tilde.club) [tildeverse](https://tildeverse.org)  

### in class assignment
Everyone make a minimal node server, with an endpoint that serves a message. Add your computer's IP address and port(s) to [this google sheet](https://docs.google.com/spreadsheets/d/1Geq0eVsVNMHlhbMsSgQ6eXJzn8NPMJuBecdh-K2EpmE/edit?usp=sharing), then query other peoples' endpoints. Can you make a message that changes when other people see it?

To serve a webpage that just says 'hello world', 

```
var http = require('http');

http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World!');
}).listen(8080); 
```

obvious limitations and their solutions:
* only . this can be solved temporarily using a service like ngrok, which configures an outward 
* when i shut my laptop, the server turns off!

If you're making a performance web server, chances are you're not writing it yourself, as there's a lot of really complex things it has to do to perform consistently under different conditions. Popular web servers are things like [Nginx](https://en.wikipedia.org/wiki/Nginx) (pronounced 'engine X', not 'n-ginks'), and [Apache](https://en.wikipedia.org/wiki/Apache_HTTP_Server). These boast all kinds of fancy features that you'd struggle to write by hand, but are possibly overkill for smaller projects like the ones we'll do in class.

### assignment:
*due {{page.assignment-due}}*<br>
{{page.assignment}}

'Information' here is pretty broad, but it should be something that changes over time. Maybe it's something happening on the keyboard, a button you're clicking, or how many tabs you have open in google right now...
